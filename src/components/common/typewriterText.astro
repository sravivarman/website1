---
export interface Props {
    text: string | string[];
    speed?: number;
    deleteSpeed?: number;
    pauseTime?: number;
    class?: string;
}

const {
    text,
    speed = 100,
    deleteSpeed = 50,
    pauseTime = 2000,
    class: className = "",
} = Astro.props;
const textData = Array.isArray(text) ? JSON.stringify(text) : text;
---

<span class={`typewriter ${className}`} data-text={textData} data-speed={speed} data-delete-speed={deleteSpeed} data-pause-time={pauseTime}></span>

<script>
class TypewriterEffect {
    private element: HTMLElement;
    private texts: string[];
    private currentTextIndex: number = 0;
    private speed: number;
    private deleteSpeed: number;
    private pauseTime: number;
    private currentIndex: number = 0;
    private isDeleting: boolean = false;
    private timeoutId: number | null = null;

    constructor(element: HTMLElement) {
        this.element = element;
        const textData = element.dataset.text || '';

        // 尝试解析为JSON数组，如果失败则作为单个字符串处理
        try {
            const parsed = JSON.parse(textData);
            this.texts = Array.isArray(parsed) ? parsed : [textData];
        } catch {
            this.texts = [textData];
        }

        this.speed = parseInt(element.dataset.speed || '100');
        this.deleteSpeed = parseInt(element.dataset.deleteSpeed || '50');
        this.pauseTime = parseInt(element.dataset.pauseTime || '2000');

        // 添加调试信息（仅在开发环境或需要时）
        if (element.dataset.debug === 'true' || window.location.hostname === 'localhost') {
            console.log('Typewriter initialized:', {
                texts: this.texts,
                speed: this.speed,
                deleteSpeed: this.deleteSpeed,
                pauseTime: this.pauseTime,
                element: this.element
            });
        }

        // 如果有多条文本且未启用打字机效果，随机显示一条
        if (this.texts.length > 1 && !this.isTypewriterEnabled()) {
            this.showRandomText();
        } else {
            this.start();
        }
    }

    private isTypewriterEnabled(): boolean {
        // 检查是否有打字机相关的数据属性
        return this.element.dataset.speed !== undefined ||
               this.element.dataset.deleteSpeed !== undefined ||
               this.element.dataset.pauseTime !== undefined;
    }

    private showRandomText() {
        const randomIndex = Math.floor(Math.random() * this.texts.length);
        this.element.textContent = this.texts[randomIndex];
    }

    private start() {
        if (this.texts.length === 0) return;
        
        // 确保元素可见后再开始动画
        const checkVisibilityAndStart = () => {
            const rect = this.element.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(this.element);
            
            if (computedStyle.display !== 'none' && 
                computedStyle.visibility !== 'hidden' && 
                parseFloat(computedStyle.opacity) > 0) {
                this.type();
            } else {
                // 如果元素不可见，等待一段时间后重试
                setTimeout(checkVisibilityAndStart, 200);
            }
        };
        
        checkVisibilityAndStart();
    }

    private getCurrentText(): string {
        return this.texts[this.currentTextIndex] || '';
    }

    private type() {
        const currentText = this.getCurrentText();

        if (this.isDeleting) {
            // 删除字符
            if (this.currentIndex > 0) {
                this.currentIndex--;
                this.element.textContent = currentText.substring(0, this.currentIndex);
                this.timeoutId = window.setTimeout(() => this.type(), this.deleteSpeed);
            } else {
                // 删除完成，切换到下一条文本
                this.isDeleting = false;
                this.currentTextIndex = (this.currentTextIndex + 1) % this.texts.length;
                this.timeoutId = window.setTimeout(() => this.type(), this.speed);
            }
        } else {
            // 添加字符
            if (this.currentIndex < currentText.length) {
                this.currentIndex++;
                this.element.textContent = currentText.substring(0, this.currentIndex);
                this.timeoutId = window.setTimeout(() => this.type(), this.speed);
            } else {
                // 打字完成，暂停后开始删除（如果有多条文本）
                if (this.texts.length > 1) {
                    this.isDeleting = true;
                    this.timeoutId = window.setTimeout(() => this.type(), this.pauseTime);
                }
                // 如果只有一条文本，保持显示不删除
            }
        }
    }

    public destroy() {
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
    }
}

let typewriterInstances: TypewriterEffect[] = [];
let initializationAttempts = 0;
const MAX_INITIALIZATION_ATTEMPTS = 10;

function initializeTypewriters() {
    // 清理之前的实例
    typewriterInstances.forEach(instance => instance.destroy());
    typewriterInstances = [];
    
    const typewriterElements = document.querySelectorAll('.typewriter');
    
    // 检查元素是否可见和可用
    const visibleElements = Array.from(typewriterElements).filter(element => {
        const rect = element.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(element);
        return computedStyle.display !== 'none' && 
               computedStyle.visibility !== 'hidden' && 
               computedStyle.opacity !== '0' &&
               (rect.width > 0 || rect.height > 0);
    });
    
    if (visibleElements.length === 0 && initializationAttempts < MAX_INITIALIZATION_ATTEMPTS) {
        initializationAttempts++;
        // 如果没有可见元素，稍后重试
        setTimeout(initializeTypewriters, 200);
        return;
    }
    
    visibleElements.forEach((element) => {
        const instance = new TypewriterEffect(element as HTMLElement);
        typewriterInstances.push(instance);
    });
    
    initializationAttempts = 0;
}

function waitForElementsAndInitialize() {
    const checkElements = () => {
        const typewriterElements = document.querySelectorAll('.typewriter');
        if (typewriterElements.length > 0) {
            initializeTypewriters();
        } else if (initializationAttempts < MAX_INITIALIZATION_ATTEMPTS) {
            initializationAttempts++;
            setTimeout(checkElements, 100);
        }
    };
    checkElements();
}

// 多重初始化策略以确保在各种环境下都能工作
if (typeof window !== 'undefined') {
    // 策略 1: DOMContentLoaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(waitForElementsAndInitialize, 100);
        });
    } else {
        // 如果DOM已经加载完成
        setTimeout(waitForElementsAndInitialize, 100);
    }
    
    // 策略 2: window load (备用方案)
    window.addEventListener('load', () => {
        setTimeout(() => {
            if (typewriterInstances.length === 0) {
                waitForElementsAndInitialize();
            }
        }, 1500); // 给loading overlay充足时间完成动画
    });
    
    // 策略 3: 延迟初始化 (为GitHub Pages等慢环境提供额外时间)
    setTimeout(() => {
        if (typewriterInstances.length === 0) {
            waitForElementsAndInitialize();
        }
    }, 2000);
}

// 支持页面切换时重新初始化
document.addEventListener('swup:contentReplaced', () => {
    initializationAttempts = 0;
    initializeTypewriters();
});
</script>

<style>
.typewriter {
    position: relative;
}

.typewriter::after {
    content: '|';
    animation: blink 1s infinite;
    margin-left: 2px;
}

@keyframes blink {
    0%, 50% {
        opacity: 1;
    }
    51%, 100% {
        opacity: 0;
    }
}
</style>